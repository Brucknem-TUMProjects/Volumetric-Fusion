#version 430

uniform int INVALID_TSDF_VALUE;
uniform float resolution;
uniform float resolutionInv;
uniform vec3 size;
uniform vec3 sizeHalf;
uniform vec3 sizeNormalized;
uniform vec3 origin;
uniform mat4 relativeTransformation;
uniform mat4 coordinate_correction;
uniform float new_tsdf;

layout (local_size_x = 1) in;

struct VtxData {
   vec4  vtx_pos;       // 4N [GOOD] -- Largest base alignment
   vec4  vtx_tsdf;    // 3N [BAD]
};                      // ^^ 12 * sizeof (GLfloat) per-vtx

// std140 is pretty important here, it is the only way to guarantee the data
//   structure is aligned as described above and that the stride between
//     elements in verts[] is 0.
layout (std140, binding = 1) buffer VertexBuffer {
   VtxData verts [];
};

vec3 unhash(uint hash){
    int x = int(hash % int(sizeNormalized.x));
    int y = int(int(hash / sizeNormalized.x) % int(sizeNormalized.y));
    int z = int(int(hash/ int(sizeNormalized.x * sizeNormalized.y)) % int(sizeNormalized.z));

    vec3 pos = vec3(x, y, z);
    pos *= resolution;
    pos -= sizeHalf;
    pos += origin;

    return pos;
}

void main(){	
    uint hash = gl_GlobalInvocationID.x;

    vec3 pos = unhash(hash);

    verts[hash].vtx_pos = vec4(pos, 1.0f);
    verts[hash].vtx_tsdf = vec4(hash, new_tsdf, 0, 1);
}